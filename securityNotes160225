
UserManagement :

@SuppressWarnings("deprecation")
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
	@Override
	protected void configure(HttpSecurity http) throws Exception { //configure(HttpSecurity http) is used to define the urls to be protected
		//and define the authentication methods and also to define the various application artifacts such as cors to be enable
		http.authorizeRequests()
		.antMatchers("/").permitAll() //this will allow all urls to access meaning without security
		.antMatchers("/dashboard").authenticated() //should be authenticate
		.antMatchers("/doctor").authenticated() //should be authenticate
		.and()
		.formLogin() //either through form login
		.and()
		.httpBasic(); //or through httpbasic means via postman headers
	}
	
	//instead of default generated user details such as user and generated password
	//define our custom user details may be in memory user details manager or jdbc user details manager, etc
	//using AuthenticationManagerBuilder
	//AuthenticationManagerBuilder will build the AuthenticationManager
	//AuthenticationManager will be implemented by the AuthenticationProvider 
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception { //is used to build mostly for the custom authenticationprovider and custom userdetailsmanager, inmemoryuserdetailsmanager
		//AuthenticationManagerBuilder is used to build the AuthenticationManager, that AuthenticationManager will provides the Authentication details to the AuthenticationProvider
		//AuthenticationManagerBuilder is also used to define the UserDetailsManager to create the users schema
		auth.inMemoryAuthentication() //this inmemoryuserdetailsmanager take all these users and calling the userdetails => createuser
		//inMemoryAuthentication() => InMemoryUserDetailsManagerConfigurer => InMemoryUserDetailsManager => createUser
		//createUser(UserDetails user) = given user details
		//finally the users are added into the user map
		.withUser("admin").password("admin").authorities("admin") //our own user store using in memory
		.and()
		.withUser("user").password("user").authorities("user");
		//if we run the application, we will get the exception as : java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id "null"
		//because AuthenticationProvider will verify the password what we are enter with the password present in UserDetailsService using PasswordEncoder
		//this PasswordEncoder used by the AuthenticationProvider
		//that is the reason, while authenticating, AuthenticationProvider have not found any
		//PasswordEncoder, and hence we got the PasswordEncoder error here
		//configure PasswordEncoder
	}
	//seperating the passwordencoder
	@Bean
	public PasswordEncoder passwordEncoder(){
		return NoOpPasswordEncoder.getInstance();
	}
	@Override
	public void configure(WebSecurity web) throws Exception { //to static resources should have to be unsecure
		web.ignoring().antMatchers("/assets/**"); //this configure(WebSecurity web) is mostly used for ignoring the security check on the static resources
	}
}

//beans we can define with @Bean, those beans we can define in the class which annotated with @Configuration

==================jdbcauthentication============
@SuppressWarnings("deprecation")
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

	@Autowired
	private DataSource dataSource;
	@Override
	protected void configure(HttpSecurity http) throws Exception { 
		http.authorizeRequests()
		.antMatchers("/").permitAll()
		.antMatchers("/dashboard").authenticated()
		.antMatchers("/doctor").authenticated()
		.and()
		.formLogin()
		.and()
		.httpBasic();
	}
	
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		/*auth.inMemoryAuthentication()
		.withUser("admin").password("admin").authorities("admin")
		.and()
		.withUser("user").password("user").authorities("user");*/

		//jdbcauthentication
		//if we configure the AuthenticationManagerBuilder with the jdbcAuthentication, that jdbcAuthenticationmanager internally will use the
		//userdetails as the JdbcUserDetailsManager
		//AuthenticationManager will use jdbcauthenticationprovider, jdbcauthenticationprovider will use this JdbcUserDetailsManager
		//JdbcUserDetailsManager will excepting the users and authorities tables
		//the below boolean values for the users table's enable column values
		// 0 - disable
		// 1 - enable
		// /resources/sql/scripts.sql => run this scripts in sql editor of the mysql work bench
		//so, required tables were created i.e. users table and authorities table which are expected by the JdbcUserDetailsManager
		//jdbcAuthentication uses the JdbcUserDetailsManager
		//internally the AuthenticationManagerBuilder is building the AuthenticationManager(jdbcauthentication, inmemoryauthentication, ldapauthentication)
		//that AuthenticationManager internally uses the AuthenticationProvider uses the DaoAuthenticationProvider
		//DaoAuthenticationProvider will have retrieveUser, this method will use the underlying
		//getUserDetailsService().loadUserByUsername(username); while verifying the userdetails that were entered by us
		auth.jdbcAuthentication().dataSource(dataSource);
	}
	@Bean
	public PasswordEncoder passwordEncoder(){
		return NoOpPasswordEncoder.getInstance();
	}
	@Override
	public void configure(WebSecurity web) throws Exception {
		web.ignoring().antMatchers("/assets/**");
	}
}
================
default authenticationprovider is daoauthenticationprovider

@SuppressWarnings("deprecation")
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

	@Autowired
	private DataSource dataSource;
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.authorizeRequests()
		.antMatchers("/").permitAll()
		.antMatchers("/dashboard").authenticated()
		.antMatchers("/doctor").authenticated()
		.and()
		.formLogin()
		.and()
		.httpBasic();
	}

	/*@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth.jdbcAuthentication().dataSource(dataSource);
	}*/
	//we can configure userdetailsmanager in another way such that without authenticationmanagerbuilder, we can configure
	//authenticationmanager will take the authentication request, that request gives to the authenticationprovider(default provider is daoauthenticationprovider)
	//that daoauthenticationprovider will use the userdetailsservice what we have exposed here and also use the passwordencoder
	//by using these two things, the authenticationprovder will take the decision whether the user is loggedin or not
	@Bean
	public UserDetailsService userDetailsService(){
		//inmemory
		/*InMemoryUserDetailsManager inMemoryUserDetailsManager = new InMemoryUserDetailsManager();
		UserDetails user1 = new User("admin", "admin", Arrays.asList(new SimpleGrantedAuthority("admin")));
		UserDetails user2 = new User("user", "user", Arrays.asList(new SimpleGrantedAuthority("user")));

		inMemoryUserDetailsManager.createUser(user1);
		inMemoryUserDetailsManager.createUser(user2);

		return inMemoryUserDetailsManager;*/

		//jdbc
		JdbcUserDetailsManager jdbcUserDetailsManager = new JdbcUserDetailsManager(dataSource);
		return jdbcUserDetailsManager;

		//upto here we have done usermanagement
		//cognito is the idp like wso2, keyclock
	}
	@Bean
	public PasswordEncoder passwordEncoder(){
		return NoOpPasswordEncoder.getInstance();
	}
	@Override
	public void configure(WebSecurity web) throws Exception {
		web.ignoring().antMatchers("/assets/**");
	}
}

passwordmanagement :
daoauthenticationprovider is the default authenticationprovider will have a retrieveUser(--) method through this, it will
retrieve the userdetails from the database based on the username that we have supplied throught the form
once this retrieveUser(--) is successful, then it will create authentication response object by using the method called
createSuccessAuthentication(Object principal, Authentication authentication, UserDetails user)

=============
password security :
encoding : we will do the conversion from one form to the another
there is no salting, no cryptography, no aes algorithm, etc
any one can easily decode if we use the encoded string
this is do not use, not suggestible
encoding is useful for compress files(zip files)
encryption : 2 types
symmetric : the data will be encrypted with some key know to only server which is generating the encryption
single secrete key is used for encrypt and decrypt
ex : jwt token
asymmetric : two keys : public and private keys are used
certificate based authentication will be the best example for this asymmetric algorithm
https://developer.hashicorp.com/vault/tutorials/pki/pki-engine
read that hashicorp tutorial

root certificate self signed certificate contains private key
intermediate certificate contains the signature of the root certificate, signed intermediate certificate private key and save the generated certificate as .pem i.e. a public key is generating that public key is signed with the private key of the root certificate
intermediate certificate contains the both the things i.e. private certificate and public certificate that means private key of the root certificate plus public certificate that is able to exchange with any one
for ex : medi.ex.com
we can create a certificate which contains a public key i.e. application contains a public key will be exchanged to the pki(public key infrastructure registry) contains the certificate(public key + private key)
public key should same with the public key of the intermediate certificate
application’s certificate public key = intermediate certificate public key then the authentication is success
tls and ssl designed using asymmetric authentication
hashing : nothing but compressing the data, hashing is a technique which is used to converting the data using some hashing functions having to take string or text then run for various iterations, compress our text
ex : md5, shah256 => non breakable
shah256 = plain text to encrypted text
md5 = to generate shah256 strength is unbreakable
in the hasing there is no revers process
once string is generated/hashed, we can’t reverse it
cryptography properties :
confidentiality : shouldn’t be breakable
integrity : double layer checking
authenticity : should be happened with the streangthen password
spring security provided the password encoder those encoders will use the hashing techniques
jwt generators will use the symmetric encryption
tls encryption of type asymmetric
spring security password encoders that will encode the data and hash the data but won’t encrypt the data
shah1 length < shah256 length < shah512 length
salt = random string
pbkdf2 = password based key derivation function 2
hmac = hash message authentication code

daoauthenticationprovider is getting the userdetails from the database and checking whether
this password is encodedpassword and mathcing the incoming password(that we entered) is equals to the
hashed string or not with the help of the matches(--) of the encoder